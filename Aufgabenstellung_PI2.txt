Praktikum Informatik 2:
Aufgabenstellung

September 22, 2025

Contents
1 Motivation

3

2 Zielaufgabe

4

3 Hinweise zur Implementierung
3.1 Verwaltung der Verkehrssimulation . . . . . . . . . . . . . . . . . . . . .
3.2 Verwaltung der Projekte . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 Neues Projekt anlegen . . . . . . . . . . . . . . . . . . . . . . . .
3.2.2 C++-Dateien erzeugen . . . . . . . . . . . . . . . . . . . . . . . .
3.2.3 Inhalte in neue Projekte uÌˆbernehmen . . . . . . . . . . . . . . . .
3.3 Namenskonvention . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.4 Programmierhinweise . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

8
8
8
8
9
10
10
11

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
12
4.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
4.2 Fahrzeuge (Einfache Klassen) . . . . . . . . . . . . . . . . . . . . . . . . 12
4.3 FahrraÌˆder und PKW (Unterklassen) . . . . . . . . . . . . . . . . . . . . . 15
4.4 Ausgabe der Objekte (Operatoren uÌˆberladen) . . . . . . . . . . . . . . . 17
5 Aufgabenblock 2: Erweiterung des Verkehrssystems
19
5.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
5.2 Kopieren des Projektes . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20
5.3 Simulationsobjekte und Wege . . . . . . . . . . . . . . . . . . . . . . . . 20
5.4 Parkende und fahrende Fahrzeuge . . . . . . . . . . . . . . . . . . . . . . 22
5.5 Losfahren, Streckenende (Exception Handling) . . . . . . . . . . . . . . . 24
5.6 Grafische Ausgabe . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
5.7 VerzoÌˆgertes Update (Template) . . . . . . . . . . . . . . . . . . . . . . . 27
6 Aufgabenblock 3: Simulation des Verkehrssystems
32
6.1 Motivation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.2 UÌˆberholverbot . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
6.3 Aufbau des Verkehrssystems . . . . . . . . . . . . . . . . . . . . . . . . . 34
6.4 Verkehrssystem als Datei (File Streams, map) . . . . . . . . . . . . . . . 36

2

1 Motivation
WaÌˆhrend des Praktikums sollen alle wesentlichen Elemente objektorientierter Softwareentwicklung und ihre Umsetzung im Sprachumfang von C ++ an einem (vereinfachten)
Beispiel eingesetzt und geuÌˆbt werden. Dabei sollen die modernen Pointerkonzepte der
Smartpointer eingesetzt werden. Zur Darstellung oft benutzter Datenstrukturen wie
Vektor, Liste oder Assoziativspeicher sollen die Klassen der Standard Template Library
(ST L) kennengelernt und benutzt werden. Die Aufgabe besteht aus aufeinander aufbauenden Teilaufgaben, die schlieÃŸlich zu der GesamtloÌˆsung fuÌˆhren. Die einzelnen Aufgaben sind zu drei BloÌˆcken zusammengefasst. FuÌˆr jeden Block wird ein Testat abgenommen. Die Aufgaben sollen so implementiert werden, dass fuÌˆr jeden Block ein neues
Projekt mit Eclipse angelegt wird. Dazu wird der vorhandene Block kopiert und dann
erweitert. Somit sollte ein Testprogramm aus Block1 auch am Ende des Praktikums
noch funktionieren.

3

2 Zielaufgabe
Es soll der StraÃŸenverkehr in einer wenig erschlossenen Gegend modelliert und simuliert
werden (siehe 2.1).
Verschiedene Arten von Fahrzeugen (PKW, Fahrrad) werden zu einem individuellen
Startzeitpunkt von einem Knotenpunkt (Kreuzung) losgeschickt. Jedes Fahrzeug besitzt
einen Zeit- und einen StreckenzaÌˆhler sowohl fuÌˆr die Gesamtstrecke als auch fuÌˆr den
Streckenabschnitt, auf dem es sich gerade befindet. Die Daten des Streckennetzes und
der eingesetzten Fahrzeuge werden uÌˆber Konstruktoren gesetzt oder eingelesen.
Das Modell setzt sich aus drei verschiedenen Simulationsobjekten zusammen: Fahrzeuge,
Wege und Kreuzungen. Eine Verbindung zwischen zwei Kreuzungen wird durch eine
StraÃŸe realisiert, die aus zwei entgegen gerichteten Wegen (Hin- und RuÌˆckweg) gebildet
wird. Jeder Weg verwaltet die auf dem Weg befindlichen Fahrzeuge, jede Kreuzung die
aus ihr abgehenden Wege. Wege koÌˆnnen sowohl fahrende als auch parkende Fahrzeuge
annehmen. Wenn die Simulation den Startzeitpunkt des parkenden Fahrzeugs erreicht,
wird aus diesem ein fahrendes Fahrzeug.
Alle Simulationsobjekte enthalten eine Funktion, die einen Simulationsschritt ausfuÌˆhrt.
Kreuzungen simulieren dabei die von ihnen abgehenden Wege und Wege die auf ihnen
befindlichen Fahrzeuge. Zu jedem Zeitschritt werden also durch die Simulation aller
Kreuzungen des Systems nacheinander alle Simulationsobjekte bearbeitet. Das System
wird durch einen globalen Zeittakt gesteuert. In jedem Zeittakt werden alle im System befindlichen Objekte genau einmal simuliert. Dies wird erreicht, indem jeweils
die letzte Simulationszeit des Simulationsobjektes mit der globalen Zeit verglichen und
anschlieÃŸend synchronisiert wird. Auf einigen Wegen des Simulationssystems herrscht
teilweise UÌˆberholverbot, d.h. in einem Simulationsschritt darf ein Fahrzeug die Position des auf diesem Weg vorausfahrenden Fahrzeugs nicht uÌˆberschreiten. Auch besteht
auf den Wegen aufgrund ihrer Art (Stadtstrasse, Landstrasse, Autobahn) ggf. eine
Geschwindigkeitsbegrenzung.
Einen UÌˆberblick uÌˆber den Hauptteil der Simulation bietet die in Figure 2.2 dargestellte
Klassenstruktur. UnterstuÌˆtzende Klassen finden Sie in Figure 2.3. Obwohl sicher
auch andere Strukturen und Implementationen moÌˆglich waÌˆren, gehen wir im Praktikum von dieser Struktur aus. Es werden nicht alle Funktionen aufgefuÌˆhrt (keine
Konstruktoren/Destruktoren), teilweise werden die Funktionen nur in der hierarchisch
am hoÌˆchsten gelegenen Klasse dargestellt. Sie koÌˆnnen durchaus in abgeleiteten Klassen
uÌˆberschrieben werden. Bitte verwenden Sie in Ihrer Implementierung die dort aufgefuÌˆhrten
Klassen- und Funktionsnamen, um den Betreuenden bei Fragen eine schnelle Orientierung zu ermoÌˆglichen. SelbstverstaÌˆndlich koÌˆnnen (und muÌˆssen) Sie zur Implementierung und zum Test einzelner Module weitere Klassen und/oder Funktionen einfuÌˆhren.
Die Aufgaben bauen aufeinander auf, so dass am Ende des Praktikums die Simulation

4

2 Zielaufgabe

Figure 2.1: Simulationsmodell
komplett implementiert ist. Die Funktionen fuÌˆr die grafische Ausgabe werden Ihnen zur
VerfuÌˆgung gestellt. In der Grafik sind PKWs durch rote und FahrraÌˆder durch gruÌˆne
Punkte dargestellt. Das in der Liste jeweils selektierte Fahrzeug wird blau markiert.
Bevor Sie mit den Aufgaben beginnen, lesen Sie bitte die gesamte Aufgabenstellung durch, damit Sie wissen, wozu Klassen und Funktionen spaÌˆter
genutzt werden.
Im Anschluss finden Sie noch einige Vorgaben und Programmierhinweise.

5

2 Zielaufgabe

Figure 2.2: Klassenhierarchie Simulationsobjekt

6

2 Zielaufgabe

Figure 2.3: Ausnahme- und Verhaltensklassen

7

3 Hinweise zur Implementierung
Im Folgenden werden einige Hinweise zum DurchfuÌˆhren des Praktikums gegeben. Diese
sollten nach MoÌˆglichkeit eingehalten werden, um den Betreuenden die Arbeit zu erleichtern und moÌˆgliche Fehlerquellen zu verringern. Die Aufgaben des Praktikums werden
mit der Entwicklungsumgebung Eclipse bearbeitet. Sie werden feststellen, dass Eclipse
viele MoÌˆglichkeiten fuÌˆr die C++-Programmierung bietet. Im Rahmen des Praktikums
wird nur auf einen kleinen Teil der FunktionalitaÌˆten von Eclipse eingegangen. Ihnen
steht es natuÌˆrlich frei, sich tiefergehend in Eclipse einzuarbeiten und weitergehende
Funktionen zu verwenden.

3.1 Verwaltung der Verkehrssimulation
Die Aufgaben sind in drei AufgabenbloÌˆcke unterteilt. Jeder Aufgabenblock soll als Projekt Aufgabenblock X (mit X=1,2,3) angelegt werden und in dem ausgewaÌˆhlten Eclipse
Workspace gespeichert werden. In der zugehoÌˆrigen main()-Funktion soll dann fuÌˆr jede
Aufgabe eine entsprechende Funktion vAufgabe X() aufgerufen werden, welche die FunktionalitaÌˆt der entsprechenden Aufgabe testet.

3.2 Verwaltung der Projekte
3.2.1 Neues Projekt anlegen
Da in der Vergangenheit dabei immer wieder Probleme aufgetreten sind, gibt es an dieser
Stelle nun eine detaillierte Anleitung.
1. OÌˆffnen Sie F ile â†’ N ew â†’ P roject.
2. Im geoÌˆffnetem Fenster waÌˆhlen Sie C/C ++ â†’ C/C ++ P roject aus und bestaÌˆtigen
mit N ext.
3. WaÌˆhlen Sie in dem neuen Fenster nun All â†’ C + + M anaged Build aus und
bestaÌˆtigen erneut mit N ext.
4. Nun geben Sie unter P roject name den entsprechenden Projektnamen (z.B. Aufgabenblock 1) ein und waÌˆhlen als P roject type â†’ Executable â†’ Empty P roject
aus. Auf der rechten Seite waÌˆhlen sie als T oolchain M inGW GCC aus. Die
Location koÌˆnnen Sie auf der Standardeinstellung lassen. BestaÌˆtigen Sie nun mit
F inish (s. Figre 3.1).

8

3 Hinweise zur Implementierung

Figure 3.1: Neues Projekt anlegen

3.2.2 C++-Dateien erzeugen
1. WaÌˆhlen Sie im P roject Explorer das entsprechende Projekt aus. Klicken Sie
mit der rechten Maustaste auf das Projekt. In dem sich oÌˆffnenden KontextmenuÌˆ
waÌˆhlen Sie N ew. Nun haben Sie unter anderem die Auswahl zwischen
a) Header F ile: Hiermit koÌˆnnen Sie eine leere .h-Datei erzeugen. Dabei muÌˆssen
Sie den Dateinamen (in Anlehnung an die Klasse, z.B. Fahrzeug.h) angeben
und ein Template auswaÌˆhlen. Als Template waÌˆhlen Sie hier Default C++
header template aus.
b) Source F ile: HieruÌˆber erzeugen Sie eine leere C + +-Datei. Als Dateinamen
geben Sie z.B. Fahrzeug.cpp an. WaÌˆhlen Sie als Template das Default C++
source template aus.
c) Class: Mit Hilfe dieses MenuÌˆeintrags laÌˆsst sich eine gesamte Klasse mit
Header- und Source-Dateien erzeugen. In der Abfrage muÌˆssen Sie ein Source
f older angeben (das Projekt, z.B. Aufgabenblock 1), den Klassennamen
definieren (z.B. Fahrzeug) und uÌˆber M ethod stubs lassen sich einige grundlegende Konstruktoren und Destruktoren automatisch erzeugen.
2. Sie finden die erzeugte Datei nun in Ihrem Projektverzeichnis und koÌˆnnen Sie
entsprechend mit Inhalt und FunktionalitaÌˆt fuÌˆllen.

9

3 Hinweise zur Implementierung

3.2.3 Inhalte in neue Projekte uÌˆbernehmen
1. ZunaÌˆchst folgen Sie den ersten drei Schritten um ein neues Projekt anzulegen.
2. Als N ame waÌˆhlen Sie nun Aufgabenblock 2 bzw. 3
3. Nun bestaÌˆtigen Sie und in Ihrem W orkspace wird ein neues Unterverzeichnis Aufgabenblock X angelegt.
4. Kopieren Sie die Sourcen aus dem Verzeichnis des alten Projekts in das neue Projektverzeichnis (wichtig: es sollen nur die *.h und *.cpp Dateien kopiert werden!).
Kopieren Sie zusaÌˆtzlich, sofern vorhanden die Vorgabedateien aus Moodle.
5. In Eclipse muÌˆssen Sie nun die neuen Dateien im neuen Projekt laden. Dazu waÌˆhlen
Sie im P roject Explorer das neu erstellte Projekt aus und druÌˆcken F 5. Dadurch
laÌˆdt Eclipse die neuen Dateien und diese werden nun im Projekt angezeigt.
Hinweis: Um ein Projekt auszufuÌˆhren, waÌˆhlen Sie es im P roject Explorer
aus und waÌˆhlen nun P roject â†’ Build P roject aus. Dadurch wird Ihr Projekt
kompiliert. Als naÌˆchstes koÌˆnnen Sie das Projekt uÌˆber Run â†’ Run as â†’ 2
local C / C + + Application ausfuÌˆhren.

3.3 Namenskonvention
Benutzen Sie bitte in all Ihren LoÌˆsungen folgende PraÌˆfixe fuÌˆr Variablen und Funktionen.
Es erleichtert Ihnen (und auch uns) das Lesen des Quellcodes, da aus dem Namen unter
anderem auch schon der Typ der Variablen/Funktionen ersichtlich ist.
â€¢ Instanzvariablen der Klassen werden durch ein p ganz vorne am Variablennamen
gekennzeichnet.
â€¢ Darauf folgt ein Buchstabe, der den Typ der Variablen bzw. den RuÌˆckgabewert
der Funktion beschreiben.
i=int; t=struct; d=double; v=void; b=bool;
s=string; p=pointer; e=enum;
â€¢ Danach folgt dann der eigentliche Variablenname, wobei der erste Buchstabe eines
jeden Teilwortes groÃŸgeschrieben wird.
â€¢ Im speziellen Fall, dass die Funktion nur eine private/protected Variable setzt oder
zuruÌˆckliefert, ist das erste Wort des eigentlichen Variablennamens get bzw. set und
danach folgt der Name der Variablen ohne die obigen PraÌˆfixe. Diese Funktionen
heiÃŸen auch getter/setter-Methoden.
â€¢ Eine Funktion wird dadurch gekennzeichnet, dass dem Namen runde Klammern
folgen.

10

3 Hinweise zur Implementierung
Beispiele:
â€¢ p iID: protected/private-Variable vom Typ int
â€¢ bIstFertig(): Funktion, die einen boolschen Wert zuruÌˆckliefert (true oder f alse
â€¢ getID(): getter fuÌˆr die Variable (p iID).
â€¢ vFunktion(): Funktion, die nichts (void) zuruÌˆckliefert.

3.4 Programmierhinweise
â€¢ Implementieren Sie fuÌˆr jede Klasse eine Datei Klassenname.h zur Deklaration
der Variablen und Funktionen. Weiterhin jeweils eine Datei Klassenname.cpp zur
Definition des Codes.
â€¢ Neben den Funktionen, die zur LoÌˆsung der Aufgaben vorgegeben werden, koÌˆnnen
Sie natuÌˆrlich zusaÌˆtzlich noch eigene Funktionen implementieren.
â€¢ Kommentieren Sie Ihre Programme ausreichend, sodass auch AuÃŸenstehende (Betreuende) Ihren Code nachvollziehen koÌˆnnen. Dieser Punkt geht auch mit in die
Bewertung ein.
â€¢ Entscheiden Sie, ob es bei der Definition von Funktionen, Variablen oder Parametern sinnvoll ist, diese als const zu deklarieren. WaÌˆhlen Sie dies, wo immer es
moÌˆglich ist.
â€¢ Sie koÌˆnnen, wenn Sie mehrere Elemente der ST L verwenden hinter die jeweiligen
Includes using namespace std; schreiben. Bedenken Sie, dass dies nicht die Regel
ist.
â€¢ Alle Dateien, die wir Ihnen im Laufe des Praktikums zur VerfuÌˆgung stellen, finden
Sie im RWTHmoodle Lehr- und Lernbereich des Praktikums unter Vorgabedateien.
â€¢ Denken Sie an die aufeinander aufbauende Programmstruktur der Aufgabe.
â€¢ Testen Sie alle erstellten Klassen und Funktionen fuÌˆr (weitgehend) alle denkbaren
Situationen. Ein einzelner Test zeigt noch nicht die Korrektheit des Programms.
WaÌˆhlen Sie entsprechend mehrere repraÌˆsentative TestfaÌˆlle und begruÌˆnden Sie Ihre
Testauswahl. Dieser Punkt (z.B. â€â€˜UÌˆberseheneâ€â€™ TestfaÌˆlle oder nur automatisierte
Zufallstests) geht auch in die Bewertung ein.

11

4 Aufgabenblock 1: Grundlagen des
Verkehrssystems
4.1 Motivation
In diesem ersten Aufgabenblock werden Klassen fuÌˆr die zu simulierenden Fahrzeuge
erstellt, PKWs und FahrraÌˆder, die sich selbst fortbewegen koÌˆnnen und simulierbar
sind. Ein Mini-Eventhandler ruft eine entsprechende Simulationsschrittmethode aller
Fahrzeuge mehrmals auf und gibt den aktuellen Stand der Fahrzeuge nach jedem Schritt
auf dem Bildschirm aus.
In diesem Aufgabenblock werden folgende Punkte betrachtet:
â€¢ Deklaration und Definition von Klassen,
â€¢ Implementierung von Konstruktoren und Destruktoren,
â€¢ Kapselung von Daten und Zugriff auf private Member,
â€¢ Elementare Verwendung von Smartpointern und static Variablen,
â€¢ Vererbung,
â€¢ Einsatz der ST L (string, vector),
â€¢ Unterscheidung der Klassenbereiche public, private und protected,
â€¢ Unterscheidung einfache und virtuelle Vererbung,
â€¢ UÌˆberladen von Operatoren.
Um sich einen UÌˆberblick zu verschaffen, lesen Sie den ersten Aufgabenblock
zunaÌˆchst komplett durch.

4.2 Fahrzeuge (Einfache Klassen)
1. Starten Sie Eclipse und erstellen Sie in Ihrem Homebereich ein neues Projekt mit
dem Namen Aufgabenblock 1.

12

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
2. AÌˆndern Sie den C++-Dialekt Ihres Projektes auf C++-17. Dazu klicken Sie mit
der rechten Maustaste auf Ihr Projekt und waÌˆhlen â€Propertiesâ€ aus. Hier waÌˆhlen
Sie nun â€C/C + + Build â†’ Settingsâ€ aus. Auf der rechten Seite waÌˆhlen Sie
nun den Reiter â€Tool Settingsâ€. Hier oÌˆffnen Sie nun â€GCC C + + Compiler â†’
Dialectâ€. Im rechten Bereich waÌˆhlen Sie nun unter â€Language standardâ€ â€ISO
C++ 17 (-std=c++17)â€.
3. Implementieren Sie eine Klasse F ahrzeug zur Verwaltung verschiedener Fahrzeuge.
Die Klasse soll zunaÌˆchst lediglich private Membervariablen haben, in denen der
Name des Fahrzeugs (p sName) und eine eindeutige ID (p iID) zu jedem Objekt
gespeichert wird. Benutzen Sie fuÌˆr den Namen den Datentyp string. Implementieren Sie einen Konstruktor, der einen string als Parameter hat und damit den
Namen initialisiert. Weiterhin soll die Klasse mit einem Default-Konstruktor konstruierbar sein. Dann soll der Name leer (â€â€) sein. Zum Initialisieren der Variablen
koÌˆnnen Sie diese direkt bei der Definition mit 0 bzw. â€â€ vorbesetzen. Die ID soll
im Konstruktor anhand einer hochzaÌˆhlenden, Klassenvariablen p iMaxID vergeben
werden. Nutzen Sie im Konstruktor eine Initialisierungsliste, um die Konstanten
einmalig mit einem Wert zu besetzen. Da sich die ID nach der Konstruktion
nicht mehr aÌˆndert, koÌˆnnen Sie diese als const definieren. Wie Sie Klassenvariablen
definieren, koÌˆnnen Sie im Skript (Statische Klassenelemente) nachlesen.
Erzeugen Sie in den Konstruktoren und dem Destruktor eine Ausgabe, welche den
Namen und die ID des erzeugten bzw. geloÌˆschten Objekts mit einem entsprechenden Hinweis auf die Operation auf der Standardausgabe cout ausgibt.
FuÌˆr das weitere Programm setzen Sie da, wo Sie koÌˆnnen, Variablen und Funktionen
bevorzugt const.
4. Beim Programmieren ist es meist ratsam, schnell ein lauffaÌˆhiges Programm zu
haben. Erzeugen Sie eine neue C++-Datei (main.cpp), die die Funktion vAufgabe 1() aufruft und implementieren Sie diese Funktion innerhalb der Datei main.cpp.
Erzeugen Sie in dieser Funktion einige Elemente statisch (uÌˆber Deklaration) und
einige dynamisch (mit new). LoÌˆschen Sie zum Schluss die dynamisch erzeugten
Elemente. Erzeugen und starten Sie das Programm und testen Sie das korrekte Erzeugen und LoÌˆschen der Objekte. Im Anschluss erzeugen Sie nun einige
Smartpointer (siehe Skript). Benutzen Sie dazu make unique<Fahrzeug> und
make shared<Fahrzeug>, um von beiden Typen je 2 Objekte vom Typ Fahrzeug
zu erzeugen. Speichern Sie eines der als shared ptr erzeugten Objekte in einem
weiteren shared ptr. Lassen Sie sich vor und nach der Zuweisung mit use count die
Anzahl der Referenzen ausgeben. Versuchen Sie dasselbe mit unique ptr. Erzeugen Sie zusaÌˆtzlich einen vector<unique ptr<Fahrzeug>>. Speichern Sie die oben
erzeugten Fahrzeuge in diesem Vektor. Welche Fahrzeuge koÌˆnnen Sie dort speichern? Wie muÌˆssen Sie den Besitzwechsel anzeigen? LoÌˆschen Sie danach den Vektor
mit clear. Beobachten Sie mit dem Debugger, was dort passiert und wann die
Objekte durch Aufruf des Destruktors geloÌˆscht werden.

13

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
Erzeugen Sie nun zusaÌˆtzlich auch einen vector<shared ptr<Fahrzeug>>. Welche
Fahrzeuge koÌˆnnen Sie dort speichern? FuÌˆgen Sie dem Vektor zwei Fahrzeuge hinzu,
eins mit und eins ohne move. Lassen Sie die Anzahl der Referenzen ausgeben.
Beobachten Sie wieder mit dem Debugger, was dort passiert und wann die Objekte durch Aufruf des Destruktors geloÌˆscht werden. Bitte notieren Sie beim Debuggen, in welchen Zeilen die jeweiligen Objekte geloÌˆscht werden. Machen Sie sich
in dieser Aufgabe mit den Grundfunktionen des Debuggers (SchrittmoÌˆglichkeiten,
Haltepunkte) bekannt. Beobachten Sie im Fenster fuÌˆr die VariablenuÌˆberwachung
den Inhalt der Variablen. Die Benutzung des Debuggers wird im Skript beschrieben.
Die Funktionen des Debuggers muÌˆssen bei der Abnahme ggf. vorgefuÌˆhrt und
erlaÌˆutert werden.
5. Erweitern Sie die Klasse um Membervariablen fuÌˆr die Maximalgeschwindigkeit
des Fahrzeugs (p dMaxGeschwindigkeit), die bisher zuruÌˆckgelegte Gesamtstrecke
(p dGesamtStrecke), die gesamte Fahrzeit des Objektes (p dGesamtZeit) und die
Zeit, zu der das Fahrzeug zuletzt simuliert wurde (p dZeit). FuÌˆgen Sie einen
weiteren Konstruktor hinzu, der einen Namen und die maximale Geschwindigkeit
als Parameter bekommt. Beachten Sie hier, dass die Geschwindigkeit immer positiv
sein soll. PruÌˆfen Sie dies in der Initialisierungsliste mit Hilfe des ?-Operators.
6. Da dieses Programm noch nicht viel am Bildschirm ausgibt, schreiben Sie eine
Memberfunktion vAusgeben(). Diese Memberfunktion soll spezifische Fahrzeugdaten ausgeben. Machen Sie innerhalb dieser Funktion keine Aufrufe von cout::endl,
sondern programmieren Sie die Zeilenwechsel in der Hauptfunktion. Die Ausgabe
soll so formatiert werden, dass unter einer UÌˆberschrift die Daten tabellarisch aufgelistet werden, in etwa folgendermaÃŸen:
ID
Name
MaxGeschwindigkeit Gesamtstrecke
---------------------------------------------------1 PKW1
40.00
0.00
2 AUTO3
30.00
0.00

Die UÌˆberschrift soll durch eine Klassenfunktion void vKopf() ausgegeben werden.
Benutzen Sie fuÌˆr die Formatierung keine feste Anzahl von Leerzeichen, sondern die
Input-Output-Manipulatoren der Standard C++ Bibliothek (<iomanip>). Schreiben
Sie eine Klassenfunktion in Fahrzeug, um mit Fahrzeug::vKopf() die UÌˆberschrift
ausgeben zu koÌˆnnen. Beachte: Bei Verwendung von setiosflags() zum Setzen der
Ausgabeausrichtung (rechts-/linksbuÌˆndig) sollte zunaÌˆchst die andere Ausrichtung
mittels resetiosflags() zuruÌˆckgesetzt werden.
7. Bevor die Simulationsfunktion der Fahrzeuge geschrieben werden kann, muss erst
noch eine globale Uhr programmiert werden, damit die Fahrzeuge wissen, wie
viele Stunden sie simulieren sollen. Zur Realisierung dieser Uhr definieren Sie eine
globale Variable dGlobaleZeit, die Sie mit 0.0 initialisieren.

14

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
Beachte: Zur Benutzung dieser Variablen innerhalb anderer Klassen muss sie der
Klasse erst mittels der extern-Deklaration bekannt gemacht werden.
8. Schreiben Sie nun die Memberfunktion Fahrzeug::vSimulieren(), welche dafuÌˆr sorgt,
dass die Fahrzeuge sich fortbewegen. Dazu wird mit Hilfe der globalen Uhr ermittelt, wieviel Zeit seit dem letzten Simulationsschritt vergangen ist, und entsprechend
dieser Information wird der Zustand des Fahrzeugs aktualisiert (u.a. Gesamtstrecke um die im ermittelten Zeitraum aufgrund der Geschwindigkeit fahrbare
Strecke erhoÌˆhen). Lassen Sie das Fahrzeug mit maximaler Geschwindigkeit fahren.
Sorgen Sie durch einen Zeitvergleich dafuÌˆr, dass ein Fahrzeug in einem Zeitschritt
nur einmal bearbeitet wird, auch wenn es versehentlich zweimal innerhalb eines
Zeitschritts aufgerufen wird. Aktualisieren Sie auch die Gesamtfahrzeit und die
letzte Abfertigungszeit des Objektes. Momentan sind diese Werte noch gleich. Das
wird sich spaÌˆter aÌˆndern.
9. Schreiben Sie eine neue Hauptfunktion vAufgabe 1a(). Lesen Sie Namen und Maximalgeschwindigkeit fuÌˆr 3 Fahrzeuge aus der Konsole ein, erzeugen Sie diese mit
make unique<Fahrzeug> und speichern sie diese in einem Vektor. Simulieren Sie
Fahrzeuge uÌˆber eine gewisse Zeitspanne. ErhoÌˆhen Sie dazu in einer Schleife die
globale Uhr jeweils um einen Zeittakt und rufen Sie in der Schleife die Simulationsfunktion und die Ausgabefunktion der Fahrzeuge auf. WaÌˆhlen Sie als Zeittakt auch
Bruchteile von Stunden.

4.3 FahrraÌˆder und PKW (Unterklassen)
1. Implementieren Sie zwei neue Klassen P KW und F ahrrad, die jeweils von der
Basisklasse F ahrzeug abgeleitet werden. Strukturieren Sie die Klasse Fahrzeug
dementsprechend um. UÌˆberlegen Sie, welche Variablen private bleiben sollten und
welche protected werden. UÌˆberlegen Sie weiterhin, welche Funktionen virtual werden. Benutzen sie synchron dazu das SchluÌˆsselwort override fuÌˆr diese Funktionen
in den abgeleiteten Klassen. UÌˆberlegen Sie zusaÌˆtzlich welche Funktionen und/oder
Variablen Sie const setzen koÌˆnnen.
2. Da FahrraÌˆder mit Muskelkraft und PKWs mit Motoren betrieben werden, benoÌˆtigt
die Klasse P KW zusaÌˆtzliche PKW-spezifische Variablen. FuÌˆgen Sie der Klasse
P KW die Variablen p dVerbrauch (Liter/100km), p dTankvolumen sowie p dTankinhalt
(Liter) hinzu.
ErgaÌˆnzen Sie die Klasse um einen entsprechenden Konstruktor, mit dem Sie zusaÌˆtzlich
zu den fahrzeugspezifischen Membervariablen auch Verbrauch und (optional, Default=55 l) Tankvolumen setzen koÌˆnnen. Der Tankinhalt wird jeweils auf die HaÌˆlfte
des Tankvolumens initialisiert. Nutzen Sie fuÌˆr die Einbeziehung der Konstruktoren
der Basisklasse eine Initialisierungsliste.
Des Weiteren schreiben Sie eine Funktion dTanken mit optionalem Parameter
dMenge zum nachtraÌˆglichen Betanken der PKWs. Wird kein Wert uÌˆbergeben

15

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
(Defaultparameter) soll vollgetankt werden, ansonsten wird der gewuÌˆnschte Wert
getankt. Sie koÌˆnnen die Konstante std::numeric limits<double>::infinity() aus
dem Header <limits> als Default-Wert verwenden, die groÌˆÃŸer als alle (anderen)
double-Werte ist. Beachten Sie, dass maximal das Tankvolumen aufgefuÌˆllt werden
kann. Geben Sie jeweils die tatsaÌˆchlich getankte Menge zuruÌˆck. Implementieren
Sie die Funktion in der Klassenhierarchie so, dass sie fuÌˆr alle Fahrzeuge aufrufbar ist. FahrraÌˆder und Fahrzeuge ohne Tank tanken bekanntlich nicht, d.h. die
Funktion macht nichts und gibt immer 0 Liter zuruÌˆck.
Bei jedem Simulationsschritt soll der Tankinhalt aktualisiert werden, bis der Tank
leer ist. PKWs ohne Tankinhalt sollen liegenbleiben bis wieder nachgetankt wird.
Danach sollen sie normal weiterfahren. Zur Vereinfachung soll die Reserve so
groÃŸ sein, dass der P KW im letzten Schritt noch die komplette Teilstrecke fahren
kann. Implementieren Sie dazu fuÌˆr P KW eine eigene Funktion vSimulieren(),
die die zusaÌˆtzliche FunktionalitaÌˆt von P KW implementiert. FuÌˆr die allgemeine
Simulation soll aber weiterhin Fahrzeug::vSimulieren() aufgerufen werden.
Gesamtverbrauch (berechnet aus Gesamtstrecke) und aktueller Tankinhalt sollen
auÃŸerdem noch in vAusgeben ergaÌˆnzt werden. Beachte: Um Codeduplizierung in
den abgeleiteten Klassen zu vermeiden, sollen die Daten, die zu F ahrzeug gehoÌˆren,
immer von Fahrzeug::vAusgeben ausgegeben werden. Rufen Sie diese Funktion
also auch in den Ausgabefunktionen der abgeleiteten Klassen auf. ErgaÌˆnzen Sie
auch die UÌˆberschrift in Fahrzeug::vKopf() entsprechend.
3. Da Fahrradfahrer nicht immer mit maximaler Geschwindigkeit fahren koÌˆnnen,
soll eine Memberfunktion dGeschwindigkeit() implementiert werden. Sie wird in
F ahrzeug als virtuell deklariert und fuÌˆr F ahrrad uÌˆberschrieben. PKWs sollen
immer mit ihrer vollen Geschwindigkeit fahren, Fahrradfahrer dagegen werden
langsamer. Jeweils ausgehend von der gefahrenen Gesamtstrecke soll die Geschwindigkeit
pro 20km um 10% abnehmen, minimal jedoch 12km/h betragen. WaÌˆhrend eines
Berechnungsschritts ist die Geschwindigkeit als konstant anzusehen. Beispiel :
Nach 50 gefahrenen Kilometern betraÌˆgt die Geschwindigkeit im naÌˆchsten Zeittakt
noch 81% der Maximalgeschwindigkeit, falls diese noch mehr als 12km/h betraÌˆgt.
Stellen Sie nun Fahrzeug::vSimulieren() auf diese FunktionalitaÌˆt um (statt Maximalgeschwindigkeit). AÌˆndern Sie die Methode vAusgeben, sodass fuÌˆr jedes Fahrzeug
zusaÌˆtzlich zu den Fahrzeugdaten die aktuelle Geschwindigkeit ausgegeben wird.
4. Schreiben Sie eine neue Funktion vAufgabe 2(): Lesen Sie die Anzahl der zu erzeugenden PKWs und FahrraÌˆder aus der Konsole ein, konstruieren Sie entsprechende
Objekte der Klassen P KW und F ahrrad und verwalten Sie sie in einem
vector<unique ptr<Fahrzeug>>. Warum koÌˆnnen/sollten Sie keine Fahrzeugobjekte speichern? Warum koÌˆnnen Sie PKWs und FahrraÌˆder in einem gemeinsamen
Vektor speichern?
FuÌˆhren Sie fuÌˆr diese Objekte mehrere Simulationsschritte durch. Nach genau 3
Stunden tanken Sie die PKWs nochmals voll. Die Zeitabfrage dazu soll im Testpro-

16

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
gramm erfolgen, nicht innerhalb von dTanken(). Testen Sie dies mit verschiedenen
Zeittakten. Geben Sie die Ergebnisse (Daten aller Fahrzeuge) nach jedem Schritt
aus.
Beachte: Gleichheit von double-Werten kann immer nur gegen eine Toleranz 
getestet werden, da FlieÃŸkomma-Berechnungen nicht komplett genau sind. Berechnen Sie dazu z.B. den Absolutbetrag der Differenz bei Gleichheit oder reduzieren
Sie eine der Seiten des Vergleichs um  bei â‰¥ oder â‰¤. Die Funktion fuÌˆr den Absolutbetrag std::fabs() finden Sie in der Bibliothek <cmath>. Beachten Sie dieses
Rundungsproblem bei allen weiteren Vergleichen zwischen FlieÃŸkomma-Werten.

4.4 Ausgabe der Objekte (Operatoren uÌˆberladen)
1. Am Ende dieser Aufgabe sollen Fahrzeuge mit dem Ausgabeoperator angezeigt
werden koÌˆnnen. Fahrzeug hat ja bereits eine Methode vAusgeben(). Diese Memberfunktion soll nun fahrzeugspezifische Daten auf dem uÌˆbergebenen AusgabeStream ausgeben. Dazu aÌˆndern sie diese nun in eine virtuelle Methode vAusgeben(ostream&) const. Markieren Sie in allen Fahrzeug-Klassen die geerbte
vAusgeben-Methode als override, falls noch nicht geschehen.
2. Nun wollen wir Fahrzeug mit operator<< ausgeben koÌˆnnen. Dazu muÌˆssen Sie den
Ausgabeoperator uÌˆberladen. Hier zur Erinnerung nochmal die Deklaration des
Ausgabeoperators fuÌˆr eine Klasse X:
ostream& operator<<(ostream& o, const X& x);
Rufen Sie im Ausgabeoperator die vAusgeben-Methode mit dem uÌˆbergebenen ostream auf.
Beachte: UÌˆberladen Sie den Operator auÃŸerhalb der Klasse.
Warum? Kommen Sie mit einer einzigen Definition fuÌˆr alle von Fahrzeug abgeleiteten Klassen aus? Verwenden Sie bitte keine friend-Deklaration.
3. Testen Sie den Ausgabeoperator, indem Sie Fahrzeuge, PKWs und FahrraÌˆder
damit auf cout ausgeben:
Beispiel:
std::cout << *aPKW << std::endl << *aFahrrad << std::endl;
Verwenden Sie ab jetzt zur Ausgabe von Daten nur noch den <<Operator.
4. UÌˆberladen Sie in der Klasse Fahrzeug den Vergleichsoperator operator<(). Dieser
soll den Wert true liefern, falls die bisher zuruÌˆckgelegte Gesamtstrecke vom aktuellen Objekt kleiner als die vom Vergleichsobjekt ist.

17

4 Aufgabenblock 1: Grundlagen des Verkehrssystems
5. Verbieten Sie den Copy-Konstruktor, benutzen Sie hierzu delete. UÌˆberdenken Sie,
wieso dies sinnvoll ist. Wo wird er implizit aufgerufen? Was bedeutet dies in
diesem Szenario? Definieren Sie den Zuweisungsoperator (operator=()), so dass
nur die Stammdaten (Daten die bei der Erstellung festgelegt werden) kopiert werden. KoÌˆnnen Sie alle Daten kopieren? Was muÌˆssen Sie bei der ID beachten? Was
wuÌˆrde passieren, wenn Sie keine eigene Definition des Operators erstellen wuÌˆrden?
Was passiert, wenn Sie Elemente der Unterklasse zuweisen? Machen Sie sich den
Unterschied zwischen Copy-Konstruktor und Zuweisungsoperator klar. Es geht
hier nur um das prinzipielle VerstaÌˆndnis der Funktion des Zuweisungsoperators.
Die genaue Implementierung des Zuweisungsoperators spielt fuÌˆr die weitere Aufgabe keine Rolle.
6. Testen Sie alle in dieser Aufgabe neu erstellten Operatoren in einer Funktion vAufgabe 3().

18

5 Aufgabenblock 2: Erweiterung des
Verkehrssystems
5.1 Motivation
In diesem Aufgabenblock werden folgende Punkte betrachtet:
â€¢ Erweiterung einer Klassenhierarchie,
â€¢ abstrakte Klassen und rein virtuelle Methoden,
â€¢ AufzaÌˆhlungsklasse,
â€¢ Unterscheidung und Nutzung unique ptr, shared ptr, weak ptr,
â€¢ Templateklassen nutzen und erstellen,
â€¢ Exception handling und eigene Exceptionklassen,
â€¢ Nutzung einer externen Bibliothek,
â€¢ Erzeugung gleichverteilter Zufallszahlen.
In diesem zweiten Aufgabenblock wird die Klassenhierarchie um eine Klasse W eg erweitert. Da diese Klasse einige Eigenschaften mit Fahrzeugen gemeinsam hat (Name, Simulationszeit, Simulationsfunktion, Ausgabefunktion usw.), ist es sinnvoll, die Klassenhierarchie um eine abstrakte Oberklasse zu erweitern und sowohl W eg, als auch F ahrzeug
von dieser Klasse abzuleiten. Die gemeinsamen Dienste werden dann in diese abstrakte
Oberklasse verlagert. Dies ist eine bei der objektorientierten Programmierung haÌˆufig
auftretende Situation.
Ein Weg verwaltet eine Liste von Fahrzeugen und kann simuliert werden, indem alle
auf dem Weg befindlichen Fahrzeuge simuliert werden.
FuÌˆr die Berechnung der Strecke, die ein Fahrzeug in einem Simulationsschritt zuruÌˆcklegt,
wird eine neue Klasse erstellt, die ein Verhaltensmuster implementiert. Ein Verhaltensmuster ist ein Beispiel von einem Entwurfsmuster (design pattern). Jedes Fahrzeug
besitzt eine Instanz dieser Klasse und kann in seinem Simulationsschritt diese Instanz
fragen, wie weit es fahren darf. Auftretende Sondersituationen (parkendes Fahrzeug
faÌˆhrt los, fahrendes Fahrzeug kommt am Ende des Weges an) werden durch Ausnahmebehandlung (Exceptions) abgehandelt. Um die Simulation etwas anschaulicher zu
machen, wird eine Bibliothek mit Funktionen zur grafischen Darstellung verwendet.

19

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Oft wiederkehrende Datenstrukturen und Algorithmen koÌˆnnen durch Templates allgemein beschrieben werden. Die ST L stellt eine FuÌˆlle solcher vorgefertigten Strukturen
bereit. Einige davon sollen hier benutzt werden. SchlieÃŸlich soll fuÌˆr eine spezielle Listenart (verzoÌˆgerte Aktualisierung) ein eigenes Template erstellt werden.
Um sich einen UÌˆberblick zu verschaffen, lesen Sie den zweiten Aufgabenblock zunaÌˆchst komplett durch.

5.2 Kopieren des Projektes
1. Erzeugen Sie ein neues leeres Projekt mit dem Namen Aufgabenblock 2. Kopieren
Sie alle Sourcen (nur *.h und *.cpp Dateien) aus Aufgabenblock 1 und machen Sie
diese Dateien dem neuen Projekt bekannt (s. Kapitel 3.2.3).
2. AÌˆndern Sie den C++-Dialekt Ihres Projektes auf C++-17. Dazu klicken Sie mit
der rechten Maustaste auf Ihr Projekt und waÌˆhlen â€Propertiesâ€ aus. Hier waÌˆhlen
Sie nun â€C/C + + Build â†’ Settingsâ€ aus. Auf der rechten Seite waÌˆhlen Sie
nun den Reiter â€Tool Settingsâ€. Hier oÌˆffnen Sie nun â€GCC C + + Compiler â†’
Dialectâ€. Im rechten Bereich waÌˆhlen Sie nun unter â€Language standardâ€ â€ISO
C++ 17 (-std=c++17)â€.

5.3 Simulationsobjekte und Wege
1. Als erstes soll eine neue abstrakte Oberklasse Simulationsobjekt geschaffen werden, welche die gemeinsamen Eigenschaften von F ahrzeug und einer neuen Klasse
W eg zusammenfasst. Fahrzeuge und Wege sind Simulationsobjekte, die einen
Namen, eine ID und eine lokale Zeit besitzen. Sie koÌˆnnen simuliert und ausgegeben werden. Integrieren Sie F ahrzeug in diese neue Klassenhierarchie, indem
Sie die Variablen fuÌˆr Name, ID und Simulationszeit sowie alle Funktionen zur
gemeinsamen Nutzung von F ahrzeug und W eg aus der Klasse F ahrzeug in die
Klasse Simulationsobjekt uÌˆbertragen. Verschieben Sie die Ausgabe im Destruktor in die neue Klasse, um weiterhin das richtige LoÌˆschen der Objekte kontrollieren zu koÌˆnnen. LoÌˆschen Sie die jetzt uÌˆberfluÌˆssigen Variablen und Funktionen in
F ahrzeug.
Beachten Sie, dass die Variablen und Methoden in F ahrzeug angepasst bzw.
geloÌˆscht werden muÌˆssen. Simulationsobjekt ist eine abstrakte Klasse, besitzt also
mindestens eine rein virtuelle Methode. UÌˆberlegen Sie, welche Funktion hierzu
am besten geeignet ist. Welche Methoden/Variablen muÌˆssen private, protected
oder public deklariert werden? Gibt es weitere Methoden, die virtuell oder rein
virtuell deklariert werden koÌˆnnen oder muÌˆssen? Verbieten Sie auch hier den CopyKonstruktor, um fehlerhafte Elemente durch Kopien zu vermeiden. Wie muÌˆssen
Sie den Zuweisungsoperator anpassen? Implementieren Sie einen Vergleichsoperator (operator==()), der genau dann true liefert, wenn die IDs uÌˆbereinstimmen.

20

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Um Codeduplizierung zu vermeiden, sollen bei der Ausgabe die entsprechenden
vAusgeben-Methoden der uÌˆbergeordneten Klassen mitbenutzt werden. So soll
etwa vAusgeben in F ahrrad zunaÌˆchst die Methode von F ahrzeug aufrufen, diese
zunaÌˆchst die Methode von Simulationsobjekt. Simulationsobjekt::vAusgeben soll
nur die ID und den Namen des Objekts ausgeben. Aufgrund dieses Aufbaus reicht es fuÌˆr den Ausgabeoperator aus, diesen nur in der Klasse Simulationsobjekt
zu definieren. Dieses Prinzip gilt auch fuÌˆr die Konstruktoren: Die Konstruktoren
sollten jeweils die passenden Konstruktoren der Oberklasse aufrufen und nur die
eigenen Variablen der Klasse setzen. Der Aufruf des Konstruktors der Oberklasse
erfolgt in einer Initialisierungsliste.
2. Richten Sie die Klasse W eg als Unterklasse von Simulationsobjekt ein. Wege
haben zusaÌˆtzlich zu den geerbten Eigenschaften eine LaÌˆnge in km (p dLaenge), eine
Liste von Fahrzeugen (p pFahrzeuge), welche sich aktuell auf dem Weg befinden,
und eine maximal zulaÌˆssige Geschwindigkeit (p eTempolimit). Die Liste beinhaltet unique ptr auf Fahrzeuge. Zur Implementierung der Liste benutzen Sie den
Container list aus der ST L.
Es soll fuÌˆr Wege drei unterschiedliche Kategorien (Innerorts, LandstraÃŸe und Autobahn) mit unterschiedlichem Tempolimit (50km/h, 100km/h und Unbegrenzt)
geben. FuÌˆr die Autobahngeschwindigkeit koÌˆnnen Sie die Konstante
std::numeric limits<int>::max() verwenden. Definieren Sie dazu in Tempolimit.h
einen eigenen Datentyp T empolimit als AufzaÌˆhlungsklasse (enumclass) und eine
Konvertierungsfunktion getTempolimit in W eg, die fuÌˆr p eTempolimit die entsprechende
Geschwindigkeit als double zuruÌˆckgibt.
W eg soll einen Standardkonstruktor und einen Konstruktor mit Namen und LaÌˆnge
des Weges, sowie optionalem Tempolimit (default unbegrenzt) als Parameter haben.
AuÃŸerdem soll die Funktion vSimulieren() so implementiert werden, dass beim
Aufruf alle auf dem Weg befindlichen Fahrzeuge simuliert werden. Setzen Sie hierzu eine Range-basierte Schleife ein, die uÌˆber die gesamte list iteriert.
Beachte: Wenn zwei Klassen jeweils Variablen der anderen als Element enthalten
(hier enthaÌˆlt ein Weg Instanzen der Klasse Fahrzeug), koÌˆnnen Sie nicht in beiden
Headerdateien jeweils die andere Headerdatei inkludieren, da dies zu einer Rekursion fuÌˆhren wuÌˆrde. Es reicht, in den Headerdateien jeweils die andere Klasse zu
deklarieren, also einfach class Fahrzeug; bzw. class Weg; einzufuÌˆgen. In den cppDateien muÌˆssen aber dann die entsprechenden Headerdateien eingebunden werden,
da dort die Methoden benoÌˆtigt werden. Um allgemein Probleme mit zirkulaÌˆren
AbhaÌˆngigkeiten (circular dependencies) in Headerdateien zu vermeiden, kann man
meistens folgende Faustregel anwenden: Nur, wenn von einer Klasse geerbt wird,
ist es notwending die andere Header-Datei in der Header-Datei einzubinden. Bei
allen anderen Klassen reicht in der Headerdatei eine Deklaration. FuÌˆr cpp-Dateien
gilt das nicht: Dort muÌˆssen alle benutzten Headerdateien eingebunden werden, um
die Schnittstellen der Funktionen bereitzustellen.
Implementieren Sie eine Funktion vAusgeben fuÌˆr W eg, damit der uÌˆberladene Aus-

21

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
gabeoperator verwendet werden kann. Die Funktion soll die Implementierung von
Simulationsobjekt fuÌˆr ID und Name verwenden und selbst die LaÌˆnge des Weges
und in Klammern die Namen der auf dem Weg befindlichen Fahrzeuge ausgeben.
Definieren Sie auch hier eine Klassenfunktion vKopf() zur Ausgabe einer UÌˆberschrift
fuÌˆr Wege wie folgt:
ID | Name
| Laenge | Fahrzeuge
-----------------------------------------------0 weg
:
100 ( )
3. Testen Sie Ihr altes Hauptprogramm. Es sollte noch unveraÌˆndert funktionieren.
In vAufgabe 4() testen Sie zusaÌˆtzlich die neue Klasse W eg, indem Sie einen Weg
erzeugen und ihn mit dem <<-Operator auf die Standardausgabe ausgeben.

5.4 Parkende und fahrende Fahrzeuge
1. Damit man fuÌˆr ein Fahrzeug verschiedene Verhaltensweisen realisieren kann, wird
die Klasse F ahrzeug um eine Membervariable p pVerhalten erweitert, die eine
Instanz der im Folgenden noch zu implementierenden Klasse V erhalten verwaltet.
Durch Austausch dieses Objektes kann das Verhalten des Fahrzeugs veraÌˆndert
werden, ohne ein neues Fahrzeug erstellen zu muÌˆssen. UÌˆberlegen Sie, welche Art
von Smartpointer fuÌˆr p pVerhalten gewaÌˆhlt werden sollte.
Unter Verhalten verstehen wir, dass zwischen fahrenden und parkenden Fahrzeugen
unterschieden werden kann.
Da das Verhalten u.a. vom jeweiligen Weg abhaÌˆngt, bekommt die Klasse V erhalten
einen Konstruktor, der eine Referenz auf einen W eg als Parameter bekommt und
speichert. Weiterhin soll eine Funktion double dStrecke(Fahrzeug& aFzg, double
dZeitIntervall) angeboten werden, die ermittelt, wie weit ein Fahrzeug innerhalb
des uÌˆbergebenen Zeitintervalls fahren kann, ohne das Wegende zu uÌˆberschreiten.
Die bisherige Berechnung der aktuellen Teilstrecke in Fahrzeug::vSimulieren wird
durch den Aufruf der Funktion dStrecke ersetzt. Zum lesenden Zugriff auf private
Variablen von Weg und Fahrzeug muÌˆssen ggf. neue Getter-Funktionen geschrieben
werden. Beachten Sie, dass dStrecke in jedem Simulationsschritt nur einmal aufgerufen
wird und das Zwischenergebnis lokal zwischengespeichert wird.
Bei jedem Start eines Fahrzeugs auf einem neuen Weg soll nun eine Instanz von
V erhalten erzeugt und in F ahrzeug gespeichert werden.Dies geschieht am besten
durch eine neue Memberfunktion Fahrzeug::vNeueStrecke(Weg&), die ein geeignetes
Objekt erzeugt und in p pVerhalten speichert. Was passiert mit der alten Instanz,
wenn das Fahrzeug auf einen neuen Weg gesetzt wird?
Da Fahrzeuge jetzt nacheinander auf verschiedenen Wegen fahren sollen, fuÌˆhren wir
hier eine zusaÌˆtzliche Membervariable p dAbschnittStrecke in Fahrzeug ein. Diese
speichert immer nur die auf dem aktuellen Weg zuruÌˆckgelegte Strecke. Sie wird

22

5 Aufgabenblock 2: Erweiterung des Verkehrssystems

Figure 5.1: Funktionsweise dStrecke()
in gleicher Weise wie bisher p dGesamtStrecke aktualisiert und beim Betreten des
Weges auf 0 gesetzt.FuÌˆgen Sie diese Variable Ihren Berechnungen und Ausgaben fuÌˆr
F ahrzeug hinzu. Die Variable p dGesamtStrecke soll weiterhin gepflegt werden.
Da es zurzeit noch keine EinschraÌˆnkungen fuÌˆr die Fahrzeuge gibt, soll die Funktion
dStrecke, wie in Figure 5.1 gezeigt, die auf Grundlage der uÌˆbergebenen Zeitspanne
fahrbare Strecke zuruÌˆckliefern, falls dadurch die WeglaÌˆnge noch nicht uÌˆberschritten
wird (dT1 . . . dTnâˆ’1 ). Im Zeittakt dTn soll nur die bis zum Wegende verbleibende
Strecke zuruÌˆckgegeben werden, womit das Fahrzeug genau am Ende des Weges
ankommt. Im letzen Zeittakt dTn+1 wird dann erkannt, dass das Fahrzeug am
Ende des Weges steht. ZunaÌˆchst soll das Programm hier nur eine entsprechende
Meldung ausgeben, dass es am Ende des Weges angekommen ist.
2. Schreiben Sie nun eine Funktion Weg::vAnnahme(unique ptr<Fahrzeug>), die ein
Fahrzeug auf dem Weg annimmt. Dazu muss es in die Liste der Fahrzeuge eingetragen werden. Da ein unique ptr nicht kopiert werden kann, muss der Pointer
auf das Fahrzeug mit move verschoben werden. Damit man die eingetragenen
Fahrzeuge auch sehen kann, werden diese in Klammern an die Ausgabe des Weges
angehaÌˆngt. Weiterhin muss dem Fahrzeug signalisiert werden, dass es sich auf
einer neuen Strecke befindet.
Beispiel:
ID | Name
| Laenge | Fahrzeuge
-----------------------------------------------0 weg
:
100 ( BMW Audi BMX )
3. Testen Sie Ihre neue Klasse in vAufgabe 5(), indem Sie einen Weg und drei Fahrzeuge
erzeugen, diese auf den Weg setzen und den Weg simulieren.
4. Der Simulation sollen nun parkende Fahrzeuge hinzugefuÌˆgt werden. Parkende
Fahrzeuge benoÌˆtigen ein anderes Verhaltensmuster, da diese sich nicht fortbewegen.

23

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Erweitern Sie dazu die Klasse V erhalten zu einer Klassenhierarchie, wobei Sie zwei
Klassen F ahren und P arken von V erhalten ableiten.
V erhalten soll als abstrakte Oberklasse implementiert werden. F ahren soll funktionieren wie vorher V erhalten. Implementierten Sie daher fuÌˆr F ahren den Code
nicht doppelt, sondern uÌˆbernehmen diesen. Die Klasse P arken hat einen Konstruktor, der zusaÌˆtzlich zum Weg den Startzeitpunkt des Fahrzeugs uÌˆbergeben
bekommt. Parken::dStrecke() liefert bis zum Erreichen des Startzeitpunktes den
Wert 0.0 zuruÌˆck. Wenn die Startzeit erreicht wurde, soll das Programm auch hier
zunaÌˆchst eine entsprechende Meldung ausgeben.
Auf einem Weg sollen sich sowohl parkende als auch fahrende Fahrzeuge befinden
koÌˆnnen. Um beide zu unterscheiden, soll die Funktion vAnnahme(unique ptr<Fahrzeug>)
durch eine weitere Funktion vAnnahme(unique ptr<Fahrzeug>, double) uÌˆberladen
werden. Bekommt sie nur einen Zeiger auf Fahrzeug als Argument, dann nimmt
sie wie bisher ein fahrendes Fahrzeug an.Wird jedoch ein Zeiger auf Fahrzeug und
eine Startzeit uÌˆbergeben, nimmt sie ein parkendes Fahrzeug an. Alle Fahrzeuge
sollen weiterhin zusammen in der vorhandenen Liste verwaltet werden.
UÌˆberladen Sie entsprechend auch die Funktion Fahrzeug::vNeueStrecke. FuÌˆgen
Sie fahrende Fahrzeuge hinten in die Liste an, parkende Fahrzeuge vorne. Diese
Eigenschaft werden wir spaÌˆter noch benoÌˆtigen.
5. Modifizieren Sie vAufgabe 5 mehrfach so, dass das Programm beim Starten bzw.
am Streckenende entsprechende Meldungen ausgibt. Alternativ koÌˆnnen Sie dies
auch mit Hilfe des Debuggers testen.

5.5 Losfahren, Streckenende (Exception Handling)
1. Sie haben bisher an zwei Stellen im Programm nur eine Meldung fuÌˆr das Losfahren
und das Streckenende. Stattdessen soll nun jeweils eine Ausnahme (Exception)
geworfen werden (throw), die dann in der Simulationsmethode des Weges aufgefangen (catch) und abgearbeitet werden kann. Da Sie zwei verschiedene Arten
von Ausnahmen werfen, ist es vernuÌˆnftig, eine Klassenhierarchie fuÌˆr diese AusnahmefaÌˆlle zu erstellen.
Leiten Sie dazu zwei Klassen Losf ahren und Streckenende von einer abstrakten
Klasse F ahrausnahme ab. ZusaÌˆtzlich leiten sie die Klasse F ahrausnahme von der
Klasse exception aus der der C++ Standardbibliothek ab. UÌˆberlegen Sie sich was
das fuÌˆr Vorteile mitbringt.F ahrausnahme soll eine Referenz auf F ahrzeug und
eine Referenz auf W eg als Membervariable besitzen. Diese speichern jeweils das
Fahrzeug und den Weg, bei denen die Ausnahme aufgetreten sind.Implementieren
Sie auch einen entsprechenden Konstruktor, der die beiden Referenzen setzt. Weiterhin hat die Klasse eine rein virtuelle Funktion vBearbeiten(). Geben Sie in den
beiden Bearbeitungsmethoden der Unterklassen vorerst nur Fahrzeug, Weg und
Art der Ausnahme aus.

24

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Beim Auftreten der Ausnahmen (bisher Ausgaben) sollen nun die entsprechenden
Objekte geworfen und in der Simulationsroutine des Weges aufgefangen werden.
Nachdem ein Ausnahmeobjekt gefangen wurde, wird fuÌˆr dieses einfach nur die
Bearbeitungsfunktion vBearbeiten() ausgefuÌˆhrt.
Beachte: Fangen Sie beide Ausnahmen mit nur einem catch-Block. Wieso ist
das moÌˆglich?
2. UÌˆber die Klasse V erhalten haben Fahrzeuge und die davon abgeleiteten Klassen
Kenntnis vom befahrenen Weg. BeruÌˆcksichtigen Sie die Maximalgeschwindigkeit
(Weg::p eTempolimit), die fuÌˆr den befahrenen Weg, aber nur fuÌˆr PKW gilt, indem
Sie die Methode PKW::dGeschwindigkeit() entsprechend implementieren. Definieren
Sie zum Testen einen Weg mit Tempolimit.
3. Testen Sie nun mit einer Funktion vAufgabe 6 die gerade implementierte Ausnahmebehandlung und das Tempolimit. Erzeugen Sie dazu zwei Wege (mindestens
einer mit Tempolimit) und setzen Sie fahrende und parkende Fahrzeuge auf diese
Wege und fertigen beide Wege ab.
Beachte: Die Ausnahmen Streckenende und Losf ahren werden beim Erreichen
des Wegendes bzw. des Startzeitpunkte bei jedem folgenden Simulationsschritt
erneut geworfen. Die entsprechenden Meldungen kommen also mehrfach. Da wir
noch keine Fahrzeuge von der Liste entfernen oder umsetzen, ist dieses Verhalten
kein Fehler.
4. Aufgabe zur Nutzung des Debuggers:
Kontrollieren Sie mit Hilfe des Debuggers, ob das Losfahren immer zum richtigen
Zeitpunkt auftritt. Lassen Sie dazu ein Fahrzeug beim Zeitpunkt 3.0 losfahren.
UÌˆberpruÌˆfen Sie den Startzeitpunkt einmal bei einem Zeittakt der globalen Zeit
von 0.25 und einmal bei 0.3. Korrigieren Sie ggf. Ihren Code so, dass in beiden
FaÌˆllen beim Zeitpunkt 3.0 losgefahren wird.

5.6 Grafische Ausgabe
1. Um die Simulation anschaulicher zu machen, soll sie nun grafisch dargestellt werden. Dazu wurde ein Client/Server-Modell entwickelt, bei dem der Server vom
Client uÌˆber TCP/IP Kommandos empfaÌˆngt und diese dann in eine grafische Darstellung umsetzt.
Die Grafikschnittstelle wird Ihnen durch die Klassen SimuClient und SimuClientSocket
zur VerfuÌˆgung gestellt. Der grafische Server wird uÌˆber die Java-Datei SimuServer.jar
zur VerfuÌˆgung gestellt. Um die Grafikschnittstelle nutzen zu koÌˆnnen, kopieren Sie
zunaÌˆchst die erforderlichen Dateien (SimuClient.h, Simuclient.cpp, SimuClientSocket.h,
SimuClientSocket.cpp, SimuServer.jar) in Ihr Projektverzeichnis (Verzeichnis
mit cpp/h-Dateien, z.B. Auf gabenblock 3) in Ihrem Eclipse-Workspace. Die Dateien
finden Sie in den Vorgabedateien in Moodle.

25

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Grafikschnittstelle
Die Funktionen der Grafikbibliothek arbeiten nur mit den uÌˆbergebenen Werten,
kennen also keine anderen Daten Ihres Projektes. Die Werte werden beim Aufruf
aber auf syntaktische und semantische PlausibilitaÌˆt gepruÌˆft. Das bedeutet:
a) Zahlenwerte muÌˆssen in einem sinnvollen Wertebereich liegen.
b) Die Namen duÌˆrfen nur Buchstaben, Ziffern und
keine Leerzeichen.

enthalten, insbesondere

c) Fahrzeuge koÌˆnnen nur auf StraÃŸen gezeichnet werden, die vorher durch zwei
Wege definiert wurden.
Die Grafikschnittstelle stellt folgende Funktionen zur VerfuÌˆgung:
â€¢ bInitialisiereGrafik(int GroesseX, int GroesseY);
Mit dieser Funktion stellen Sie eine Verbindung zum Grafikserver her und initialiseren Sie die GroÌˆÃŸe des Fensters. Die Variablen GroesseX und GroesseY
bestimmen die GroÌˆÃŸe der Grafikdarstellung. Verwenden Sie hier z.B. folgende
Werte: GroesseX=800; GroesseY= 500
bInitialisiereGrafik(800, 500);
â€¢ vSetzeZeit(double Zeit)
Mit dieser Funktion koÌˆnnen Sie die globale Zeit in der Titelzeile des Ausgabefensters anzeigen lassen.
â€¢ bZeichneStrasse(string NameHin, string NameRueck, int Laenge, int AnzahlKoord, int[] Koordinaten)
Diese Funktion zeichnet eine StraÃŸe, die aus den beiden durch ihren Namen
identifizierten Wegen besteht. Die StraÃŸe soll mit einer Reihe von Koordinaten dargestellt werden. Der Verlauf der StraÃŸe wird durch einen Polygonzug mit mindestens 2 Punkten (Gerade) skizziert. Die Koordinaten der
Polygonpunkte werden im Array Koordinaten uÌˆbergeben. Das Array enthaÌˆlt
AnzahlKoord X/Y-Paare. FuÌˆr eine gerade StraÃŸe benutzen Sie fuÌˆr Koordinaten z.B. die Werte
{ 700, 250, 100, 250 }.
Beachte:
a) Achten Sie darauf, dass die X-/Y-Koordinatenwerte innerhalb der vorher
definierten (bInitialisiereGrafik()) Grenzen liegen.
b) Das Array muss genau (2 x AnzahlKoord) int-Elemente enthalten.
c) Diese Funktion darf fuÌˆr jede StraÃŸe nur einmal aufgerufen werden.
â€¢ bZeichnePKW(string PKWName, string WegName, double RelPosition, double KmH, double Tank)

26

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
â€¢ bZeichneFahrrad(string FahrradName, string WegName, double RelPosition,
double KmH)
Diese Funktionen zeichnen jeweils eine symbolische Darstellung des PKW/Fahrrads
auf dem durch seinen Namen identifizierten Weg. Die relativ zur WeglaÌˆnge
zuruÌˆckgelegte Strecke (Wert zwischen 0 und 1) wird mit RelP osition angegeben.
Dem Parameter KmH wird der Wert aus der Funktion dGeschwindigkeit(),
dem Parameter T ank der aktuelle Tankinhalt uÌˆbergeben.
â€¢ BeendeGrafik()
Mit dieser Funktion wird die Verbindung zum Grafikserver getrennt, das Fenster wird automatisch geschlossen.
â€¢ void vSleep(int zeit ms); Mit dieser Funktion wird die weitere ProgrammausfuÌˆhrung um zeitm s Millisekunden verzoÌˆgert.
2. Erweitern Sie vAufgabe 6() so, dass die Grafikausgabe getestet werden kann. FuÌˆgen
sie den Header SimuClient.h in ihrer main.cpp ein. WaÌˆhlen Sie als LaÌˆnge der beiden Wege jeweils 500km und fassen Sie diese grafisch zu einer StraÃŸe zusammen
(Hin- und RuÌˆckweg).
3. Um beim Zeichen, abhaÌˆngig vom Fahrzeugobjekt-Typ, die korrekte Zeichenfunktion aufzurufen, soll fuÌˆr PKW und Fahrrad eine Funktion vZeichnen(const Weg&)
const implementiert werden. Dazu wird in F ahrzeug die Funktion virtuell deklariert und in der jeweiligen Unterklasse uÌˆberschrieben. Die Funktion bekommt den
Weg, auf dem das Fahrzeug gezeichnet werden soll, als Referenz uÌˆbergeben und
ruft dann die passende Zeichenfunktion (s.o.) auf.
4. Lassen Sie die Fahrzeuge nach jeder Simulation in Weg zeichnen.
5. FuÌˆhren Sie Ihre Simulation aus. Um die Simulation besser verfolgen zu koÌˆnnen,
rufen Sie die Funktion vSleep in Ihrer Schleife auf. Je nach Rechenleistung des
verwendeten Computers koÌˆnnen Sie die VerzoÌˆgerung anpassen (100ms).

5.7 VerzoÌˆgertes Update (Template)
1. Wenn die Ausnahmesituationen aus der vorigen Teilaufgabe eintreten, soll nun
auch die entsprechende Aktion ausgefuÌˆhrt werden:
â€¢ Fahrzeug startet: Die parkenden Fahrzeuge sollen vorne, die fahrenden
Fahrzeuge hinten in der Liste stehen. Benutzen Sie daher fuÌˆr die Aufnahme
der Fahrzeuge entsprechend push front() bzw. push back(). Die Liste hat
dann folgenden Aufbau:
parkend...amweitestenauf W egf ahrend...amW eganf angf ahrend
Zum Starten muss das parkende Fahrzeug aus der Liste entfernt und als

27

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
fahrendes Fahrzeug sofort wieder gespeichert werden. Schreiben Sie zum
LoÌˆschen der Fahrzeuge aus der Liste eine Funktion unique ptr<Fahrzeug>
Weg::pAbgabe(const Fahrzeug&). In dieser Funktion suchen Sie in der gespeicherten list<unique ptr<Fahrzeug>> nach dem uÌˆbergebenen Fahrzeug. Benutzen Sie zum Vergleich der Fahrzeuge den operator==. Beachten Sie
den Sonderfall eines Nullpointers.Wenn Sie das Fahrzeug in der Liste gefunden haben, verschieben (move) Sie den unique ptr in eine lokale Variable und loÌˆschen dann das Fahrzeug aus der Liste. AnschlieÃŸend koÌˆnnen
Sie den zuvor lokal gespeicherten Pointer zuruÌˆckgeben. Mit den Funktionen
Weg::pAbgabe und Weg::vAnnahme kann nun die Bearbeitungsfunktion von
Losfahren entsprechend angepasst werden.
â€¢ Fahrzeug kommt am Wegende an: Passen Sie die Bearbeitungsfunktion
von Streckenende so an, dass am Streckenende ankommende Fahrzeuge aus
der Liste entfernt werden.
Testen Sie diese Funktionen: FuÌˆhren Sie dazu vAufgabe 6() nochmals aus. Je
nach Implementierung sollte es nun zu einer Fehlermeldung bei der Simulation
des Weges kommen, da der Iterator uÌˆber die Fahrzeuge nach dem LoÌˆschen bzw.
Umsetzen eines Fahrzeugs nicht mehr definiert ist und so der Nachfolger nicht
mehr bestimmt werden kann. Ebenso ist es moÌˆglich, dass Simulationsschritte von
Fahrzeugen fehlen, da in der Liste durch Umsetzen von Elementen diese nach
hinten oder vorne gerutscht sind.
Um diese Probleme zu vermeiden, soll eine allgemeine Templateklasse V Liste im
Namensbereich vertagt implementiert werden, die das EinfuÌˆgen und LoÌˆschen von
Elementen bis zum Aufruf einer Methode vAktualisieren aufschiebt. Zur Vereinfachung geben wir Ihnen das GeruÌˆst der Templateklassen in Form der Dateien
vertagt liste.h und vertagt aktion.h vor (Die Dateien finden Sie in den Vorgabedateien in Moodle). FuÌˆgen Sie diese Dateien ihrem Projekt hinzu und ergaÌˆnzen Sie
in diesen Dateien alle Bereiche, die mit [...] gekennzeichnet sind. Um sicherzugehen, dass Sie alle diese Bereich gefunden haben, koÌˆnnen Sie die Dateien in Eclipse
mit der Tastenkombination Strg + F durchsuchen.
Die Klasse V Liste hat zwei Datenelemente:
a) die Liste mit den eigentlichen Objekten (list<T> p objekte) mit den zu speichernden Elementen vom Templatetyp T
b) eine Liste zum Zwischenspeichern der noch auszufuÌˆhrenden Aktionen
(list<unique ptr<Aktion>> p aktionen).
Wir unterscheiden bei der Liste zwischen Lese- und Schreibfunktionen. Leseoperationen koÌˆnnen sofort auf der eigentlichen Liste durchgefuÌˆhrt werden, Schreiboperationen muÌˆssen als Aktion zwischengespeichert werden.
FuÌˆr die Schreib-Aktionen wird eine Klassenhierarchie mit einer abstrakten Oberklasse V Aktion angelegt, siehe Figure 5.3, die lediglich die Funktion vAusfuehren()
und eine Referenz auf die zu bearbeitende Liste (p pListe) beinhaltet. FuÌˆr jede

28

5 Aufgabenblock 2: Erweiterung des Verkehrssystems

Figure 5.2: Prinzipielle Funktionsweise von V Liste

Figure 5.3: Klassenhierarchie von V Liste

29

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Schreibfunktion wird eine zugehoÌˆrige Unterklasse von V Aktion, also V P ushF ront,
V P ushBack und V Erase abgeleitet. Dem Konstruktor der Unterklassen wird der
jeweilige Parameter der Schreibfunktion und eine Referenz auf die eigentliche Liste
uÌˆbergeben, da sonst kein Zugriff auf die Liste moÌˆglich waÌˆre. Die in den Unterklassen uÌˆberschriebene Funktion vAusfuehren() fuÌˆhrt dann die eigentliche Operation
aus.
Die Funktion vAktualisieren() der V Liste durchlaÌˆuft die Liste der anstehenden Aktionen und arbeitet jedes Element mit der Methode vAusfuehren() ab. Beachten
Sie, dass die benutzten Objekte aus der Aktionsliste entfernt werden. Die Funktionsweise von V Liste ist in Figure 5.2 nochmal schematisch dargestellt.
Folgende Funktionen sollen fuÌˆr die vertagte Liste implementiert werden:
â€¢ iterator begin(): gibt einen Iterator zuruÌˆck, der auf das erste Element zeigt
â€¢ iterator end(): gibt einen Iterator zuruÌˆck, der hinter das letzte Element zeigt
â€¢ bool empty(): gibt zuruÌˆck, ob das Objekt keine Elemente enthaÌˆlt
â€¢ void push front(T obj): fuÌˆgt obj vor dem ersten Element ein
â€¢ void push back(T obj): fuÌˆgt obj am Ende ein
â€¢ void erase(iterator it): loÌˆscht das Element an Position it
â€¢ void vAktualisieren(): aktualisiert p objekte
â€¢ void clear(): aktualisiert die Liste und loÌˆscht dann alle Elemente in p objekte
2. Testen Sie in vAufgabe 6a() Ihre neue VListe, indem Sie eine vertagt::VListe von
ganzzahligen Zufallszahlen zwischen 1 und 10 erzeugen. Folgende Aktionen sollen
nacheinander auf der Liste ausgefuÌˆhrt werden:
â€¢ Liste ausgeben
â€¢ innerhalb einer Schleife alle Elemente > 5 mit erase() loÌˆschen
â€¢ Liste wieder ausgeben (da vAktualisieren() noch nicht ausgefuÌˆhrt wurde,
sollte hier dieselbe Ausgabe erfolgen)
â€¢ vAktualisieren() auf die Liste anwenden
â€¢ Liste nochmal ausgeben (jetzt sollte sich die Liste geaÌˆndert haben).
â€¢ Zum Schluss fuÌˆgen Sie am Anfang und am Ende der Liste noch zwei beliebige
(verschiedene) Zahlen ein und geben die Liste zur Kontrolle nochmal aus.
Tipp: Eine ganzzahlige Zufallszahl zwischen a und b ermitteln Sie wie folgt:
#include <random>
static std::mt19937 device(seed);
std::uniform_int_distribution<int> dist(a, b);
int zuf = dist(device);

30

5 Aufgabenblock 2: Erweiterung des Verkehrssystems
Kurz: Wir setzen einen pseudo-random Generator ein, um Zufallszahlen zu erzeugen. In Zeile 1 erzeugen wir eine statische Variable (device), die den benutzten
Algorithmus (mt19937, d.h. Mersenne Twister Engine) und den Initialwert (seed)
festlegt. In Zeile 2 erzeugen wir eine Verteilung (Gleichverteilung mit Integerzahlen)
und legen das gewuÌˆnschte Intervall [a,b] fest. In Zeile 3 wird mit Hilfe des Generators und der Verteilung eine entsprechende Zufallszahl bestimmt. Mehrere Zufallszahlen werden durch wiederholten Aufruf von dist(device) erzeugt. FuÌˆr Details
schauen Sie sich die Bibliothek <random> an. Beachte: Wir wollen reproduzierbare Ergebnisse erhalten, daher waÌˆhlen wir einen festen Wert fuÌˆr seed (0).
3. Ersetzen Sie nun bei der Fahrzeugliste in W eg die einfache Liste durch eine entsprechende
vertagt::VListe. Sie sollten vor und nach jeder Simulation von Weg die Liste aktualisieren. Beachten Sie, dass Sie gegenuÌˆber der Nutzung des Templates fuÌˆr Integer
bei der Nutzung mit unique ptr noch Anpassungen zum Besitzwechsel durchfuÌˆhren
muÌˆssen. Testen Sie nun nochmal vAufgabe 6(). Die eventuell aufgetretene Speicherschutzverletzung sollte nun nicht mehr auftreten. Achten Sie darauf, ob die
Fahrzeuge in der Liste richtig umgesetzt und am Ende des Weges aus der Liste
geloÌˆscht werden. Kontrollieren Sie, ob auch die entsprechenden Fahrzeugobjekte
automatisch geloÌˆscht werden.

31

6 Aufgabenblock 3: Simulation des
Verkehrssystems
6.1 Motivation
Im ersten Teil dieses Blocks soll ein einfaches algorithmisches Problem implementiert
werden: Die Fahrzeuge sollen sich auf den Wegen, die ein UÌˆberholverbot haben, nicht
mehr uÌˆberholen.
Bisher koÌˆnnen nur einzelne, nicht zusammenhaÌˆngende Wege erzeugt werden und die
Fahrzeuge nur auf einem Weg fahren. Im letzten Aufgabenblock soll dies nun zu einem
vollstaÌˆndigen Verkehrsnetz zusammengefuÌˆgt werden. Zur VerknuÌˆpfung der Wege zu
einem Verkehrsnetz werden Kreuzungen eingefuÌˆhrt. Fahrzeuge werden zu Beginn parkend oder fahrend auf die Kreuzungen gesetzt. Beim Erreichen des Wegendes sollen die
Fahrzeuge auf einen anderen Weg an dieser Kreuzung wechseln und weiterfahren.
Um nicht das komplette Projekt neu uÌˆbersetzen und erzeugen zu muÌˆssen, wenn man
am Verkehrssystem etwas aÌˆndern oder mehr Fahrzeuge fahren lassen will, wird im letzten
Schritt das Verkehrsnetz aus einer Beschreibung in einer ASCII-Datei erzeugt.
In diesem Aufgabenblock werden folgende Punkte betrachtet:
â€¢ Nichttriviales AÌˆndern und Erweitern eines bestehenden Projektes,
â€¢ Implementierung eines einfachen Algorithmus,
â€¢ ST L (map),
â€¢ Daten aus einer Datei einlesen und Erzeugung der Datenstrukturen.
Um sich einen UÌˆberblick zu verschaffen, lesen Sie den dritten Aufgabenblock zunaÌˆchst komplett durch

6.2 UÌˆberholverbot
Nachfolgende Aufgaben koÌˆnnen unter dem Thema M ethodenprogrammierung zusammengefasst werden. Es impliziert, dass die Algorithmen in diesem Kapitel nicht so genau
vorgegeben sind, wie in den bisherigen Aufgaben.
1. Erstellen Sie ein neues Projekt mit dem Namen Aufgabenblock 3. Kopieren Sie
mit alle Sourcen (nur *.h und *.cpp Dateien und die SimuServer.jar) aus Aufgabenblock 2 und machen Sie diese Dateien dem neuen Projekt bekannt.

32

6 Aufgabenblock 3: Simulation des Verkehrssystems

Figure 6.1: Schranke zum Zeitpunkt bei Simulation von FZ8
2. AÌˆndern Sie den C++-Dialekt Ihres Projektes auf C++-17. Dazu klicken Sie mit
der rechten Maustaste auf Ihr Projekt und waÌˆhlen â€Propertiesâ€ aus. Hier waÌˆhlen
Sie nun â€C/C + + Build â†’ Settingsâ€ aus. Auf der rechten Seite waÌˆhlen Sie
nun den Reiter â€Tool Settingsâ€. Hier oÌˆffnen Sie nun â€GCC C + + Compiler â†’
Dialectâ€. Im rechten Bereich waÌˆhlen Sie nun unter â€Language standardâ€ â€ISO
C++ 17 (-std=c++17)â€.
3. Testen Sie noch einmal die Bearbeitungsmethoden der Ausnahmeklassen: Ein
Fahrzeug, das am Wegende ankommt, soll ausgegeben und aus der Liste geloÌˆscht
werden. Ein parkendes Fahrzeug soll beim Erreichen des Startzeitpunktes losfahren (Position innerhalb der Liste aÌˆndert sich!) und dabei seinen Namen, die
Startzeit und den Startpunkt (Weg) ausgeben.
Nach der HaÌˆlfte der Zeit soll ein weiteres Fahrzeug vom Weg (parkend) angenommen werden. Ihre Simulation sollte so lange ausgefuÌˆhrt werden, dass alle Fahrzeuge
losfahren und das Ende des Weges erreichen. Die Ausgabe soll so implementiert
werden, dass man die Umsortierung der Fahrzeuge in der Liste erkennt.
4. Da UÌˆberholen auf einigen, schlecht ausgebauten, StraÃŸen unserer Verkehrswelt
viel zu gefaÌˆhrlich ist, implementieren Sie in Fahren::dStrecke() ein UÌˆberholverbot.
Auch FahrraÌˆder duÌˆrfen nicht uÌˆberholt werden. Das Nebeneinanderfahren (gleiche
Position) kann zur Vereinfachung erlaubt werden. Das UÌˆberholverbot soll durch
eine neue boolesche Member-Variable gesteuert werden, Weg::p bUeberholverbot
b schlecht ausgebauter Weg mit UÌˆberholverbot). ErgaÌˆnzen Sie entsprechend
(true =
den Konstruktor von W eg um einen Parameter fuÌˆr das UÌˆberholverbot. Falls dieser
Parameter nicht angegeben wird, soll standardmaÌˆÃŸig davon ausgegangen werden,

33

6 Aufgabenblock 3: Simulation des Verkehrssystems
dass dieser Weg schlecht ausgebaut ist. Als weitere Bedingung kommt hinzu, dass
ein liegengebliebener P KW â€“ also ein P KW mit leerem Tank â€“ kein Hindernis
fuÌˆr nachfolgende Fahrzeuge darstellen soll.
Tipp: FuÌˆhren Sie zusaÌˆtzlich zur WeglaÌˆnge eine virtuelleSchranke ein, die jeweils
auf die Position des aktuell auf diesem Weg simulierten Fahrzeugs gesetzt wird.
Das naÌˆchste Fahrzeug darf dann nicht weiter als bis zu dieser Schranke fahren.
Schreiben Sie eine getter-Funktion fuÌˆr die virtuelle Schranke, die beruÌˆcksichtigt, ob
es ein UÌˆberholverbot auf diesem Weg gibt. Ersetzen Sie dann in den Abfragen zur
Berechnung der Reststrecke WeglaÌˆnge durch den Aufruf dieser Funktion. Machen
Sie sich klar, dass Sie wegen des speziellen Aufbaus der Liste (s. Figure 6.1)
das UÌˆberholverbot so realisieren koÌˆnnen. Andere LoÌˆsungen sind natuÌˆrlich auch
erlaubt.
5. Testen Sie das UÌˆberholverbot durch erneuten Aufruf von vAufgabe 6().

6.3 Aufbau des Verkehrssystems
1. Bisher besteht das Verkehrsnetz nur aus isolierten Wegen und darauf fahrenden
Fahrzeugen. Die Wege sollen nun mittels Kreuzungen verbunden werden. Da die
Infrastruktur gut ausgebaut ist, soll es keine EinbahnstraÃŸen geben und eine StraÃŸe
jeweils aus Hin- und RuÌˆckweg bestehen.
Erweitern Sie die Klassenhierarchie um die Klasse Kreuzung die von Simulationsobjekt
abgeleitet wird. Die Klasse Kreuzung speichert in einer Liste p pWege alle von ihr
wegfuÌˆhrenden Wege und bekommt eine Membervariable p dTankstelle. Die Variable speichert das Volumen, das einer Kreuzung zum Auftanken zur VerfuÌˆgung
steht. UÌˆberfaÌˆhrt ein P KW eine Kreuzung mit Tankstelle (p dTankstelle > 0.0),
wird er vollgetankt und p dTankstelle um die entsprechende Menge reduziert, so
lange, bis die Tankstelle leer ist. Auch hier gibt es zur Vereinfachung eine Reserve,
so dass auch der letzte P KW volltanken kann.
Schreiben Sie eine statische Methode Kreuzung::vVerbinde(...), welcher die Namen
des Hin- und RuÌˆckweges, die WeglaÌˆnge, die Start und die Zielkreuzung sowie die
guÌˆltige Geschwindigkeitsbegrenzung und das moÌˆgliche UÌˆberholverbot als Parameter uÌˆbergeben wird. Diese Funktion muss statisch sein und beide Kreuzungen
als Parameter uÌˆbergeben bekommen. Um die Kreuzungen verbinden zu koÌˆnnen,
muÌˆssen die Wege erzeugt und untereinander bekannt gemacht werden, d.h. ein
Weg kennt seinen direkten RuÌˆckweg und er weiÃŸ, auf welche Kreuzung er fuÌˆhrt.
Welche Art von Smartpointer koÌˆnnen Sie fuÌˆr die Elemente von p pWege waÌˆhlen?
Da Wege und Kreuzungen ggf. zyklisch wieder auf sich selbst verweisen, sollten die Variablen zur Speicherung der Zielkreuzung und des RuÌˆckweges vom Typ
weak ptr sein. FuÌˆgen Sie der Klasse W eg entsprechende Membervariablen hinzu.
Die Zielkreuzung kann const gewaÌˆhlt werden, da sie sich nicht veraÌˆndert. Dazu
muÌˆssen Sie den Konstruktor von Weg dementsprechend anpassen indem sie einen

34

6 Aufgabenblock 3: Simulation des Verkehrssystems
optionalen Parameter fuÌˆr die Zielkreuzung mit einem nullptr als default-Wert
einfuÌˆgen. Warum koÌˆnnen Sie die Variable fuÌˆr den RuÌˆckweg nicht const setzen?
Schreiben Sie fuÌˆr beide Variablen Getter, die einen shared ptr auf das Objekt
zuruÌˆckgeben. Wichtig hierbei ist zu beachten, dass Sie die Funktion lock() der
Smartpointer benutzen. Schauen Sie sich diese Funktion und ihre FunktionalitaÌˆt
an.
Weiterhin soll in Kreuzung die Funktion vTanken(Fahrzeug&) implementiert werden, die ggf. das uÌˆbergebene Fahrzeug volltankt und den Inhalt der Tankstelle
aktualisiert.
Implementieren Sie eine Methode Kreuzung::vAnnahme(unique ptr<Fahrzeug>,
double), die Fahrzeuge annimmt und diese parkend auf den ersten abgehenden Weg
stellt. Die Fahrzeuge sollen dabei ggf. aufgetankt werden. Nun implementieren Sie
eine Funktion Kreuzung::vSimulieren(), die alle von dieser Kreuzung abgehenden
Wege simuliert.
2. Beim Weiterleiten von Fahrzeugen sollen aus den wegfuÌˆhrenden Wegen der Kreuzung
zufaÌˆllig einer ausgewaÌˆhlt werden. Dabei soll das Fahrzeug aber nicht dieselbe
StraÃŸe zuruÌˆckfahren, die es gekommen ist. Implementieren Sie dazu eine Funktion
shared ptr<Weg> Kreuzung::pZufaelligerWeg(Weg&), die als Parameter eine Referenz auf den Weg enthaÌˆlt, uÌˆber den die Kreuzung erreicht wurde. Der RuÌˆckgabewert
soll der ausgewaÌˆhlte Weg fuÌˆr das Fahrzeug sein. Bei einer â€â€˜Sackgasseâ€â€™ muss
natuÌˆrlich der zuruÌˆckfuÌˆhrende Weg genommen werden.
Bauen Sie diese Funktion nun in die Bearbeitungsfunktion von Streckenende ein,
damit ein Fahrzeug, das am Ende des Weges angekommen ist, f ahrend auf einen
so gefundenen Weg umgesetzt wird. Dabei soll auch getankt werden. Um die Bewegungen der Fahrzeuge besser verfolgen zu koÌˆnnen, soll beim Umsetzen folgende
Ausgabe erfolgen:
ZEIT
: [Zeitpunkt der Umsetzung]
KREUZUNG : [Name der Kreuzung] [Inhalt der Tankstelle]
WECHSEL
: [Name alter Weg] â†’ [Name neuer Weg]
FAHRZEUG : [Daten des Fahrzeugs]
3. Testen Sie die bisherige Klasse Kreuzung in vAufgabe 7(), indem Sie ein Verkehrsnetz
entsprechend Figure 6.2 aufbauen und darin Fahrzeuge uÌˆber die Kreuzung Kr1 annehmen. FuÌˆr die grafische Darstellung der Kreuzung steht folgende Methode zur
VerfuÌˆgung:
void bZeichneKreuzung(int posX, int posY);
Diese Funktion zeichnet eine Kreuzung an den Koordinaten posX und posY .
Setzen Sie dann die TankkapazitaÌˆt fuÌˆr Kreuzung Kr2 auf 1000l und simulieren Sie
die Kreuzungen. Alle anderen Kreuzungen haben keine Tankstelle (TankkapazitaÌˆt
= 0).

35

6 Aufgabenblock 3: Simulation des Verkehrssystems

Figure 6.2: Koordinaten des Verkehrssystems

6.4 Verkehrssystem als Datei (File Streams, map)
1. UÌˆberladen Sie fuÌˆr Simulationsobjekte generell den Eingabeoperator operator>>().
Implementieren Sie, aÌˆhnlich der LoÌˆsung beim Ausgabeoperator operator<<(), hierfuÌˆr zuerst eine Methode vEinlesen(istream&). Die einzelnen Klassen sollen Daten
wie folgt einlesen:
Simulationsobjekt:
Kreuzung:
F ahrzeug:
P KW :
F ahrrad:

[Name]
[Simulationsobjekt] [Tankstelle in l]
[Simulationsobjekt] [MaxGeschwindigkeit in km/h]
[Fahrzeug] [Verbrauch in l/100 km] [Tankvolumen in l]
[Fahrzeug]

Implementieren Sie Simulationsobjekt::vEinlesen so, dass nur in bisher unbekannte
Objekte (p sName = â€â€) eingelesen werden kann und werfen Sie im Fehlerfalle
einen runtime error mit Fehlermeldung. Diese Exception soll im Hauptprogramm
gefangen und ausgegeben werden.
Um den neuen Operator zu testen, benutzen Sie die Datei V O.dat, die einen PKW,
ein Fahrrad und eine Kreuzung enthaÌˆlt. Kopieren Sie dazu diese Datei in das
Projektverzeichnis. OÌˆffnen Sie in vAufgabe 8() die Datei VO.dat als if stream.
Aktivieren Sie wie im Skript beschrieben die Ausnahmebehandlung des Streams.
Falls beim OÌˆffnen oder Ausgeben eine Ausnahme geworfen wird, sollen Sie diese

36

6 Aufgabenblock 3: Simulation des Verkehrssystems
ausgeben und dann das Programm abbrechen. Erzeugen Sie drei entsprechende
Objekte (Fahrrad, PKW und Kreuzung), lesen Sie diese aus der Datei ein und
geben Sie sie am Bildschirm wieder aus.
2. Um unterschiedliche Simulationen komfortabel durchfuÌˆhren zu koÌˆnnen, implementieren Sie eine Klasse Simulation, die zwei Methoden vEinlesen(istream&) und
vSimulieren() anbietet. vEinlesen bekommt einen Eingabestrom und erzeugt aus
diesem das komplette Verkehrsnetz. Der Eingabestrom besteht aus Zeilen folgender Syntax:
KREUZUNG <Kreuzungsdaten>
STRASSE <NameQ> <NameZ> <NameW1> <NameW2> <LaÌˆnge> <Tempolimit>
<UÌˆberholverbot>
PKW <PKW-Daten> <NameS> <Zeitpunkt des Losfahrens>
FAHRRAD <Fahrrad-Daten> <NameS> <Zeitpunkt des Losfahrens>
Dabei gelten folgende Wertekonventionen:
NameQ: Name der Quellkreuzung
NameZ: Name der Zielkreuzung
NameW1: Name des Weges von der Quell- zur Zielkreuzung
NameW2: Name des Weges von der Ziel- zur Quellkreuzung
Tempolimit:
enum: 1(innerorts) 2(LandstraÃŸe) 3(Autobahn)
UÌˆberholverbot:
bool: 0(falsch) oder 1(wahr)
NameS: Name der Startkreuzung
FuÌˆhren Sie fuÌˆr jede Zeile des Eingabestroms eine entsprechende Aktion durch.
Dazu erzeugen Sie ein dem SchluÌˆsselwort (KREU ZU N G, P KW, F AHRRAD)
entsprechendes leeres Objekt und lesen die vorgegebenen Daten fuÌˆr dieses Objekt
ein oder Sie verbinden zwei Kreuzungen (ST RASSE). ZaÌˆhlen Sie die Anzahl der
Zeilen mit, damit Sie im Fehlerfall die Zeilennummer ausgeben koÌˆnnen. Wenn Sie
ein unbekanntes SchluÌˆsselwort vorfinden, werfen Sie wieder einen runtime error.
Fangen Sie auÃŸerhalb der Schleife den Fehler auf, geben Sie die Zeilennummer
und die Fehlermeldung aus und reichen Sie den Fehler weiter. Zum Einlesen der
objektspezifischen Daten soll der uÌˆberladene Eingabeoperator benutzt werden.
3. Da Simulationsobjekte teilweise automatisch erzeugt werden, ist in einigen FaÌˆllen
nur der Name (string) bekannt. Um das gesamte Verkehrssystem konstruieren
zu koÌˆnnen, brauchen Sie Referenzen auf Simulationsobjekte, die Sie uÌˆber Ihren
Namen suchen koÌˆnnen. Legen Sie fuÌˆr diese Aufgabe in Simulation eine map an, die
einem Namen die entsprechende Kreuzung zuordnet. Wenn Sie beim Einlesen fuÌˆr
die Simulation eine Kreuzung erstellen, fuÌˆgen Sie diese uÌˆber ihren Namen in die
Map ein. Ist ein Objekt unter dem gewuÌˆnschten Namen bereits abgelegt, werfen Sie
einen std::runtime error mit einer entsprechenden Fehlermeldung. SpaÌˆter, wenn

37

6 Aufgabenblock 3: Simulation des Verkehrssystems
Sie Zugriff auf eine Kreuzung brauchen, benutzen Sie die Map, um die Kreuzung
nachzuschlagen. Sollte unter dem angegebenen Namen kein Objekt vorhanden
sein, soll eine Exception geworfen werden.
Testen Sie Ihre map und kontrollieren Sie, ob alle Fehleingaben abgefangen werden.
4. Implementieren Sie eine Methode Simulation::vSimulieren(double dDauer, double
dZeitschritt), die alle in der Simulation bekannten Kreuzungen fuÌˆr die angegebene
Dauer und mit dem entsprechenden Zeitschritt simuliert.
5. Implementieren Sie vAufgabe 9, welche eine Eingabedatei oÌˆffnet und die Simulation aus diesem Eingabestrom erzeugt. Benutzen Sie als Eingabedatei die Datei
Simu.dat. Die vorgegebene Datei enthaÌˆlt Fehler. Testen Sie, ob fuÌˆr alle Fehler
entsprechende Ausnahmen geworfen werden und korrigieren Sie jeweils die Fehler
in Simu.dat. Legen Sie vorher eine Kopie der Datei an. Alle Fehler sollen vom
Programm erkannt werden. Es reicht, wenn jeweils ein Fehler gefunden wird, dieser
dann von Ihnen in der Datei korrigiert wird und beim naÌˆchsten Programmaufruf
der naÌˆchste Fehler gefunden wird. Korrigieren Sie keine Fehler, bevor diese vom
Programm erkannt wurden. Das ist eine gute Gelegenheit zu uÌˆberpruÌˆfen, ob die
Zeilennummern, die bei den Fehlern ausgegeben werden, korrekt sind.
6. Als letzte Aufgabe fuÌˆhren wir die Simulation mit der grafischen Darstellung zusammen. FuÌˆgen Sie der Funktion vEinlesen einen Parameter bool bM itGraf ik hinzu,
der per Default f alse ist. Falls der Parameter in der Funktion gesetzt ist, sollen die
Syntax und das Verhalten erweitert werden. Pro SchluÌˆsselwort sollen die folgenden
zusaÌˆtzlichen Werte eingelesen werden:
â€¢ ErgaÌˆnzen eine KREU ZU N G-Zeile um die beiden Koordinaten der Position
der Kreuzung.
â€¢ Bei einer Zeile mit ST RASSE sollen die Anzahl der Koordinatenpaare und
dann fuÌˆr jedes Paar die X- und Y-Koordinaten folgen.
Implementieren Sie nun in vAufgabe 9a eine Simulation mit Grafik und nutzen Sie
als Eingabedatei fuÌˆr die Simulation SimuDisplay.dat.

38

